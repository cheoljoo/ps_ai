# problem : 25513. 빠른 오름차순 숫자 탐색 
- https://www.acmicpc.net/problem/25513

```txt
난이도 설명
설정 > 보기 > solved.ac 티어 > 보기 설정
(낮음) 5 > 1 (높음)
(낮음) 브론즈 > 실버 > 골드 > 플래티넘 > 다이아 > 루비 (높음)

(골드5) 빠른 오름차순 숫자 탐색

문제
5 x 5 크기의 보드가 주어진다. 보드는 1 x 1 크기의 정사각형 격자로 이루어져 있다. 보드의 격자에는 -1, 0, 1, 2, 3, 4, 5, 6중 하나의 수가 적혀 있다. 격자의 위치는 (r, c)로 표시한다. r은 행 번호, c는 열 번호를 나타낸다. 행 번호는 맨 위 위치가 0이고 아래 방향으로 1씩 증가한다. 열 번호는 맨 왼쪽 위치가 0이고 오른쪽으로 1씩 증가한다. 즉, 맨 왼쪽 위 위치가 (0, 0), 맨 아래 오른쪽 위치가 (4, 4)이다. -1이 적혀 있는 칸으로는 이동할 수 없고 0, 1, 2, 3, 4, 5, 6이 적혀 있는 칸으로는 이동할 수 있다.

현재 한 명의 학생이 (r, c) 위치에 있고 한 번의 이동으로 상, 하, 좌, 우 방향 중에서 한가지 방향으로 한 칸 이동할 수 있다. 학생이 현재 위치 (r, c)에서 시작하여 1, 2, 3, 4, 5, 6이 적혀 있는 칸을 순서대로 방문하려고 한다. 보드에는 1, 2, 3, 4, 5, 6이 적혀 있는 칸이 1개씩 존재하고 1, 2, 3, 4, 5, 6이 적혀 있는 칸을 여러 번 방문할 수 있다. 즉, 1이 적혀 있는 칸에서 2가 적혀 있는 칸으로 이동하고, 2가 적혀 있는 칸에서 3이 적혀 있는 칸으로 이동하고, ... , 5가 적혀 있는 칸에서 6이 적혀 있는 칸으로 이동한다. i가 적혀 있는 칸에서 i + 1이 적혀 있는 칸으로 이동할 때 다른 번호가 적힌 칸을 방문해도 된다.(1 ≤ i ≤ 5) 마찬가지로, 현재 위치 (r, c)에서 1이 적혀 있는 칸으로 이동할 때 다른 번호가 적힌 칸을 방문해도 된다. 학생이 현재 위치 (r, c)에서 시작하여 1, 2, 3, 4, 5, 6이 적혀 있는 칸을 순서대로 방문하는 최소 이동 횟수를 출력하자. 학생이 현재 위치 (r, c)에서 시작하여 1, 2, 3, 4, 5, 6이 적혀 있는 칸을 순서대로 방문할 수 없는 경우 -1을 출력한다.

입력
첫 번째 줄부터 다섯 개의 줄에 걸쳐 보드의 각 칸에 적혀있는 수가 순서대로 주어진다. i번째 줄의 j번째 수는 보드의 (i - 1)번째 행, (j - 1)번째 열에 적혀있는 수를 나타낸다. 보드의 각 칸에 적혀 있는 수는 -1, 0, 1, 2, 3, 4, 5, 6중 하나이다.

다음 줄에 학생의 현재 위치 r, c가 빈칸을 사이에 두고 순서대로 주어진다.

출력
학생이 현재 위치 (r, c)에서 시작하여 1, 2, 3, 4, 5, 6이 적혀 있는 칸을 순서대로 방문하는 최소 이동 횟수를 출력한다. 학생이 현재 위치 (r, c)에서 시작하여 1, 2, 3, 4, 5, 6이 적혀 있는 칸을 순서대로 방문할 수 없는 경우 -1을 출력한다.

제한
0 ≤ r, c ≤ 4
학생의 현재 위치 (r, c)에는 0이 적혀 있다.
1, 2, 3, 4, 5, 6이 적혀 있는 칸이 1개씩 주어진다.


예제 입력 1
0 0 1 0 0
0 0 2 0 0
0 0 3 0 0
0 0 4 0 0
0 0 5 6 -1
0 1

(0, 1) -> (0, 2) -> (1, 2) -> (2, 2) -> (3, 2) -> (4, 2) -> (4, 3)이 최소 이동이다.

예제 출력 1
6

예제 입력 2
0 0 1 0 0
0 0 2 0 0
0 0 3 0 0
0 0 4 6 0
0 0 5 -1 0
0 1

예제 출력 2
7

예제 입력 3
0 0 -1 1 0
0 0 -1 2 0
0 0 -1 3 0
0 0 -1 4 0
0 0 -1 5 6
0 1

예제 출력 3
-1

------------------------------------------------------------------
입력 처리 코드 부분

import sys
input = sys.stdin.readline

board = [list(map(int, input().split())) for _ in range(5)]
r, c = map(int, input().split())
------------------------------------------------------------------
```

# answer

## al
- 규칙
- board 에 -1 ~ 6 의 정수값이 존재
- 1 ~ 6은 하나씩만 존재
- 시작 위치는 r, c
- 1 ~ 6을 순서대로 방문할 때 최소 이동 횟수를 구하는 문제
- 불가능한 경우 -1을 리턴
- board 값 -1 은 이동 불가
- 재방문 가능

- 풀이
- BSF 를 단계별로 진행 (1 ~ 6)
- 우선순위 큐 사용 key 는 이동 거리
- 재탐색을 하지 않기 위해 visited 배열을 사용하여 이동한 위치를 체크, 재방문 가능하므로 단계별로 클리어
```python
# 메모리 35508KB 시간 36ms
import heapq
import sys
input = sys.stdin.readline

board = [list(map(int, input().split())) for _ in range(5)]
r, c = map(int, input().split())

def bfs(start_r, start_c, target):
    hq = [(0, (start_r, start_c))]
    d = [(0, 1), (0, -1), (1, 0), (-1, 0)]

    visited = [[False] * 5 for _ in range(5)]
    visited[start_r][start_c] = True

    while hq:
        p = heapq.heappop(hq)
        r = p[1][0]
        c = p[1][1]
        step = p[0]
        if board[r][c] == target:
            return step, (r, c)

        for dr, dc in d:
            nr = r + dr
            nc = c + dc
            if 0 <= nr < 5 and 0 <= nc < 5 and board[nr][nc] != -1 and visited[nr][nc] == False:
                visited[nr][nc] = True
                heapq.heappush(hq, (step + 1, (nr, nc)))

    return -1, (-1, -1)

pos = (r, c)
cnt = 0
for i in range(1, 7):
    step, pos = bfs(pos[0], pos[1], i)
    if step == -1:
        cnt = -1
        break
    cnt += step

print(cnt)
```


## peter
-
```python
```


## charles
-
```python
```


